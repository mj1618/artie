{"version":3,"sources":["../../../../../node_modules/convex/dist/esm/server/index.js","../../../../../node_modules/convex/dist/esm/server/impl/syscall.js","../../../../../node_modules/convex/dist/esm/server/impl/vector_search_impl.js","../../../../../node_modules/convex/dist/esm/server/impl/authentication_impl.js","../../../../../node_modules/convex/dist/esm/server/impl/filter_builder_impl.js","../../../../../node_modules/convex/dist/esm/server/impl/index_range_builder_impl.js","../../../../../node_modules/convex/dist/esm/server/impl/search_filter_builder_impl.js","../../../../../node_modules/convex/dist/esm/server/impl/query_impl.js","../../../../../node_modules/convex/dist/esm/server/impl/database_impl.js","../../../../../node_modules/convex/dist/esm/server/impl/scheduler_impl.js","../../../../../node_modules/convex/dist/esm/server/impl/storage_impl.js","../../../../../node_modules/convex/dist/esm/server/impl/registration_impl.js","../../../../../node_modules/convex/dist/esm/server/pagination.js","../../../../../node_modules/convex/dist/esm/server/cron.js","../../../../../node_modules/convex/dist/esm/server/router.js","../../../../../node_modules/convex/dist/esm/server/impl/actions_impl.js","../../../../../node_modules/convex/dist/esm/server/components/index.js","../../../../../node_modules/convex/dist/esm/server/schema.js","../../../../../node_modules/convex/dist/esm/server/vector_search.js","../../../../../node_modules/convex/dist/esm/server/filter_builder.js","../../../../../node_modules/convex/dist/esm/server/search_filter_builder.js","../../../../../node_modules/convex/dist/esm/server/index_range_builder.js","../../../../../node_modules/convex/dist/esm/server/impl/validate.js","../../../../../convex/_generated/api.js"],"sourcesContent":["\"use strict\";\nexport * from \"./database.js\";\nexport {\n  actionGeneric,\n  httpActionGeneric,\n  mutationGeneric,\n  queryGeneric,\n  internalActionGeneric,\n  internalMutationGeneric,\n  internalQueryGeneric\n} from \"./impl/registration_impl.js\";\nexport * from \"./pagination.js\";\nexport * from \"./search_filter_builder.js\";\nexport * from \"./storage.js\";\nexport { cronJobs } from \"./cron.js\";\nexport { httpRouter, HttpRouter, ROUTABLE_HTTP_METHODS } from \"./router.js\";\nexport {\n  anyApi,\n  getFunctionName,\n  makeFunctionReference,\n  filterApi\n} from \"./api.js\";\nexport {\n  defineApp,\n  defineComponent,\n  componentsGeneric,\n  createFunctionHandle\n} from \"./components/index.js\";\nexport { currentSystemUdfInComponent } from \"./components/index.js\";\nexport { getFunctionAddress } from \"./components/index.js\";\nexport { defineTable, defineSchema } from \"./schema.js\";\n//# sourceMappingURL=index.js.map\n","\"use strict\";\nimport { ConvexError } from \"../../values/errors.js\";\nimport { jsonToConvex } from \"../../values/value.js\";\nexport function performSyscall(op, arg) {\n  if (typeof Convex === \"undefined\" || Convex.syscall === void 0) {\n    throw new Error(\n      \"The Convex database and auth objects are being used outside of a Convex backend. Did you mean to use `useQuery` or `useMutation` to call a Convex function?\"\n    );\n  }\n  const resultStr = Convex.syscall(op, JSON.stringify(arg));\n  return JSON.parse(resultStr);\n}\nexport async function performAsyncSyscall(op, arg) {\n  if (typeof Convex === \"undefined\" || Convex.asyncSyscall === void 0) {\n    throw new Error(\n      \"The Convex database and auth objects are being used outside of a Convex backend. Did you mean to use `useQuery` or `useMutation` to call a Convex function?\"\n    );\n  }\n  let resultStr;\n  try {\n    resultStr = await Convex.asyncSyscall(op, JSON.stringify(arg));\n  } catch (e) {\n    if (e.data !== void 0) {\n      const rethrown = new ConvexError(e.message);\n      rethrown.data = jsonToConvex(e.data);\n      throw rethrown;\n    }\n    throw new Error(e.message);\n  }\n  return JSON.parse(resultStr);\n}\nexport function performJsSyscall(op, arg) {\n  if (typeof Convex === \"undefined\" || Convex.jsSyscall === void 0) {\n    throw new Error(\n      \"The Convex database and auth objects are being used outside of a Convex backend. Did you mean to use `useQuery` or `useMutation` to call a Convex function?\"\n    );\n  }\n  return Convex.jsSyscall(op, arg);\n}\n//# sourceMappingURL=syscall.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { performAsyncSyscall } from \"./syscall.js\";\nimport { version } from \"../../index.js\";\nimport {\n  FilterExpression\n} from \"../vector_search.js\";\nimport { validateArg } from \"./validate.js\";\nimport { convexOrUndefinedToJson } from \"../../values/value.js\";\nexport function setupActionVectorSearch(requestId) {\n  return async (tableName, indexName, query) => {\n    validateArg(tableName, 1, \"vectorSearch\", \"tableName\");\n    validateArg(indexName, 2, \"vectorSearch\", \"indexName\");\n    validateArg(query, 3, \"vectorSearch\", \"query\");\n    if (!query.vector || !Array.isArray(query.vector) || query.vector.length === 0) {\n      throw Error(\"`vector` must be a non-empty Array in vectorSearch\");\n    }\n    return await new VectorQueryImpl(\n      requestId,\n      tableName + \".\" + indexName,\n      query\n    ).collect();\n  };\n}\nexport class VectorQueryImpl {\n  constructor(requestId, indexName, query) {\n    __publicField(this, \"requestId\");\n    __publicField(this, \"state\");\n    this.requestId = requestId;\n    const filters = query.filter ? serializeExpression(query.filter(filterBuilderImpl)) : null;\n    this.state = {\n      type: \"preparing\",\n      query: {\n        indexName,\n        limit: query.limit,\n        vector: query.vector,\n        expressions: filters\n      }\n    };\n  }\n  async collect() {\n    if (this.state.type === \"consumed\") {\n      throw new Error(\"This query is closed and can't emit any more values.\");\n    }\n    const query = this.state.query;\n    this.state = { type: \"consumed\" };\n    const { results } = await performAsyncSyscall(\"1.0/actions/vectorSearch\", {\n      requestId: this.requestId,\n      version,\n      query\n    });\n    return results;\n  }\n}\nexport class ExpressionImpl extends FilterExpression {\n  constructor(inner) {\n    super();\n    __publicField(this, \"inner\");\n    this.inner = inner;\n  }\n  serialize() {\n    return this.inner;\n  }\n}\nexport function serializeExpression(expr) {\n  if (expr instanceof ExpressionImpl) {\n    return expr.serialize();\n  } else {\n    return { $literal: convexOrUndefinedToJson(expr) };\n  }\n}\nexport const filterBuilderImpl = {\n  //  Comparisons  /////////////////////////////////////////////////////////////\n  eq(fieldName, value) {\n    if (typeof fieldName !== \"string\") {\n      throw new Error(\"The first argument to `q.eq` must be a field name.\");\n    }\n    return new ExpressionImpl({\n      $eq: [\n        serializeExpression(new ExpressionImpl({ $field: fieldName })),\n        serializeExpression(value)\n      ]\n    });\n  },\n  //  Logic  ///////////////////////////////////////////////////////////////////\n  or(...exprs) {\n    return new ExpressionImpl({ $or: exprs.map(serializeExpression) });\n  }\n};\n//# sourceMappingURL=vector_search_impl.js.map\n","\"use strict\";\nimport { performAsyncSyscall } from \"./syscall.js\";\nexport function setupAuth(requestId) {\n  return {\n    getUserIdentity: async () => {\n      return await performAsyncSyscall(\"1.0/getUserIdentity\", {\n        requestId\n      });\n    }\n  };\n}\n//# sourceMappingURL=authentication_impl.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { convexOrUndefinedToJson } from \"../../values/value.js\";\nimport {\n  Expression\n} from \"../filter_builder.js\";\nexport class ExpressionImpl extends Expression {\n  constructor(inner) {\n    super();\n    __publicField(this, \"inner\");\n    this.inner = inner;\n  }\n  serialize() {\n    return this.inner;\n  }\n}\nexport function serializeExpression(expr) {\n  if (expr instanceof ExpressionImpl) {\n    return expr.serialize();\n  } else {\n    return { $literal: convexOrUndefinedToJson(expr) };\n  }\n}\nexport const filterBuilderImpl = {\n  //  Comparisons  /////////////////////////////////////////////////////////////\n  eq(l, r) {\n    return new ExpressionImpl({\n      $eq: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  neq(l, r) {\n    return new ExpressionImpl({\n      $neq: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  lt(l, r) {\n    return new ExpressionImpl({\n      $lt: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  lte(l, r) {\n    return new ExpressionImpl({\n      $lte: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  gt(l, r) {\n    return new ExpressionImpl({\n      $gt: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  gte(l, r) {\n    return new ExpressionImpl({\n      $gte: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  //  Arithmetic  //////////////////////////////////////////////////////////////\n  add(l, r) {\n    return new ExpressionImpl({\n      $add: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  sub(l, r) {\n    return new ExpressionImpl({\n      $sub: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  mul(l, r) {\n    return new ExpressionImpl({\n      $mul: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  div(l, r) {\n    return new ExpressionImpl({\n      $div: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  mod(l, r) {\n    return new ExpressionImpl({\n      $mod: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  neg(x) {\n    return new ExpressionImpl({ $neg: serializeExpression(x) });\n  },\n  //  Logic  ///////////////////////////////////////////////////////////////////\n  and(...exprs) {\n    return new ExpressionImpl({ $and: exprs.map(serializeExpression) });\n  },\n  or(...exprs) {\n    return new ExpressionImpl({ $or: exprs.map(serializeExpression) });\n  },\n  not(x) {\n    return new ExpressionImpl({ $not: serializeExpression(x) });\n  },\n  //  Other  ///////////////////////////////////////////////////////////////////\n  field(fieldPath) {\n    return new ExpressionImpl({ $field: fieldPath });\n  }\n};\n//# sourceMappingURL=filter_builder_impl.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { convexOrUndefinedToJson } from \"../../values/value.js\";\nimport {\n  IndexRange\n} from \"../index_range_builder.js\";\nexport class IndexRangeBuilderImpl extends IndexRange {\n  constructor(rangeExpressions) {\n    super();\n    __publicField(this, \"rangeExpressions\");\n    __publicField(this, \"isConsumed\");\n    this.rangeExpressions = rangeExpressions;\n    this.isConsumed = false;\n  }\n  static new() {\n    return new IndexRangeBuilderImpl([]);\n  }\n  consume() {\n    if (this.isConsumed) {\n      throw new Error(\n        \"IndexRangeBuilder has already been used! Chain your method calls like `q => q.eq(...).eq(...)`. See https://docs.convex.dev/using/indexes\"\n      );\n    }\n    this.isConsumed = true;\n  }\n  eq(fieldName, value) {\n    this.consume();\n    return new IndexRangeBuilderImpl(\n      this.rangeExpressions.concat({\n        type: \"Eq\",\n        fieldPath: fieldName,\n        value: convexOrUndefinedToJson(value)\n      })\n    );\n  }\n  gt(fieldName, value) {\n    this.consume();\n    return new IndexRangeBuilderImpl(\n      this.rangeExpressions.concat({\n        type: \"Gt\",\n        fieldPath: fieldName,\n        value: convexOrUndefinedToJson(value)\n      })\n    );\n  }\n  gte(fieldName, value) {\n    this.consume();\n    return new IndexRangeBuilderImpl(\n      this.rangeExpressions.concat({\n        type: \"Gte\",\n        fieldPath: fieldName,\n        value: convexOrUndefinedToJson(value)\n      })\n    );\n  }\n  lt(fieldName, value) {\n    this.consume();\n    return new IndexRangeBuilderImpl(\n      this.rangeExpressions.concat({\n        type: \"Lt\",\n        fieldPath: fieldName,\n        value: convexOrUndefinedToJson(value)\n      })\n    );\n  }\n  lte(fieldName, value) {\n    this.consume();\n    return new IndexRangeBuilderImpl(\n      this.rangeExpressions.concat({\n        type: \"Lte\",\n        fieldPath: fieldName,\n        value: convexOrUndefinedToJson(value)\n      })\n    );\n  }\n  export() {\n    this.consume();\n    return this.rangeExpressions;\n  }\n}\n//# sourceMappingURL=index_range_builder_impl.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { convexOrUndefinedToJson } from \"../../values/value.js\";\nimport {\n  SearchFilter\n} from \"../search_filter_builder.js\";\nimport { validateArg } from \"./validate.js\";\nexport class SearchFilterBuilderImpl extends SearchFilter {\n  constructor(filters) {\n    super();\n    __publicField(this, \"filters\");\n    __publicField(this, \"isConsumed\");\n    this.filters = filters;\n    this.isConsumed = false;\n  }\n  static new() {\n    return new SearchFilterBuilderImpl([]);\n  }\n  consume() {\n    if (this.isConsumed) {\n      throw new Error(\n        \"SearchFilterBuilder has already been used! Chain your method calls like `q => q.search(...).eq(...)`.\"\n      );\n    }\n    this.isConsumed = true;\n  }\n  search(fieldName, query) {\n    validateArg(fieldName, 1, \"search\", \"fieldName\");\n    validateArg(query, 2, \"search\", \"query\");\n    this.consume();\n    return new SearchFilterBuilderImpl(\n      this.filters.concat({\n        type: \"Search\",\n        fieldPath: fieldName,\n        value: query\n      })\n    );\n  }\n  eq(fieldName, value) {\n    validateArg(fieldName, 1, \"eq\", \"fieldName\");\n    if (arguments.length !== 2) {\n      validateArg(value, 2, \"search\", \"value\");\n    }\n    this.consume();\n    return new SearchFilterBuilderImpl(\n      this.filters.concat({\n        type: \"Eq\",\n        fieldPath: fieldName,\n        value: convexOrUndefinedToJson(value)\n      })\n    );\n  }\n  export() {\n    this.consume();\n    return this.filters;\n  }\n}\n//# sourceMappingURL=search_filter_builder_impl.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { jsonToConvex } from \"../../values/index.js\";\nimport { performAsyncSyscall, performSyscall } from \"./syscall.js\";\nimport {\n  filterBuilderImpl,\n  serializeExpression\n} from \"./filter_builder_impl.js\";\nimport {\n  IndexRangeBuilderImpl\n} from \"./index_range_builder_impl.js\";\nimport {\n  SearchFilterBuilderImpl\n} from \"./search_filter_builder_impl.js\";\nimport { validateArg, validateArgIsNonNegativeInteger } from \"./validate.js\";\nimport { version } from \"../../index.js\";\nconst MAX_QUERY_OPERATORS = 256;\nexport class QueryInitializerImpl {\n  constructor(tableName) {\n    __publicField(this, \"tableName\");\n    this.tableName = tableName;\n  }\n  withIndex(indexName, indexRange) {\n    validateArg(indexName, 1, \"withIndex\", \"indexName\");\n    let rangeBuilder = IndexRangeBuilderImpl.new();\n    if (indexRange !== void 0) {\n      rangeBuilder = indexRange(rangeBuilder);\n    }\n    return new QueryImpl({\n      source: {\n        type: \"IndexRange\",\n        indexName: this.tableName + \".\" + indexName,\n        range: rangeBuilder.export(),\n        order: null\n      },\n      operators: []\n    });\n  }\n  withSearchIndex(indexName, searchFilter) {\n    validateArg(indexName, 1, \"withSearchIndex\", \"indexName\");\n    validateArg(searchFilter, 2, \"withSearchIndex\", \"searchFilter\");\n    const searchFilterBuilder = SearchFilterBuilderImpl.new();\n    return new QueryImpl({\n      source: {\n        type: \"Search\",\n        indexName: this.tableName + \".\" + indexName,\n        filters: searchFilter(searchFilterBuilder).export()\n      },\n      operators: []\n    });\n  }\n  fullTableScan() {\n    return new QueryImpl({\n      source: {\n        type: \"FullTableScan\",\n        tableName: this.tableName,\n        order: null\n      },\n      operators: []\n    });\n  }\n  order(order) {\n    return this.fullTableScan().order(order);\n  }\n  // This is internal API and should not be exposed to developers yet.\n  async count() {\n    const syscallJSON = await performAsyncSyscall(\"1.0/count\", {\n      table: this.tableName\n    });\n    const syscallResult = jsonToConvex(syscallJSON);\n    return syscallResult;\n  }\n  filter(predicate) {\n    return this.fullTableScan().filter(predicate);\n  }\n  limit(n) {\n    return this.fullTableScan().limit(n);\n  }\n  collect() {\n    return this.fullTableScan().collect();\n  }\n  take(n) {\n    return this.fullTableScan().take(n);\n  }\n  paginate(paginationOpts) {\n    return this.fullTableScan().paginate(paginationOpts);\n  }\n  first() {\n    return this.fullTableScan().first();\n  }\n  unique() {\n    return this.fullTableScan().unique();\n  }\n  [Symbol.asyncIterator]() {\n    return this.fullTableScan()[Symbol.asyncIterator]();\n  }\n}\nfunction throwClosedError(type) {\n  throw new Error(\n    type === \"consumed\" ? \"This query is closed and can't emit any more values.\" : \"This query has been chained with another operator and can't be reused.\"\n  );\n}\nexport class QueryImpl {\n  constructor(query) {\n    __publicField(this, \"state\");\n    __publicField(this, \"tableNameForErrorMessages\");\n    this.state = { type: \"preparing\", query };\n    if (query.source.type === \"FullTableScan\") {\n      this.tableNameForErrorMessages = query.source.tableName;\n    } else {\n      this.tableNameForErrorMessages = query.source.indexName.split(\".\")[0];\n    }\n  }\n  takeQuery() {\n    if (this.state.type !== \"preparing\") {\n      throw new Error(\n        \"A query can only be chained once and can't be chained after iteration begins.\"\n      );\n    }\n    const query = this.state.query;\n    this.state = { type: \"closed\" };\n    return query;\n  }\n  startQuery() {\n    if (this.state.type === \"executing\") {\n      throw new Error(\"Iteration can only begin on a query once.\");\n    }\n    if (this.state.type === \"closed\" || this.state.type === \"consumed\") {\n      throwClosedError(this.state.type);\n    }\n    const query = this.state.query;\n    const { queryId } = performSyscall(\"1.0/queryStream\", { query, version });\n    this.state = { type: \"executing\", queryId };\n    return queryId;\n  }\n  closeQuery() {\n    if (this.state.type === \"executing\") {\n      const queryId = this.state.queryId;\n      performSyscall(\"1.0/queryCleanup\", { queryId });\n    }\n    this.state = { type: \"consumed\" };\n  }\n  order(order) {\n    validateArg(order, 1, \"order\", \"order\");\n    const query = this.takeQuery();\n    if (query.source.type === \"Search\") {\n      throw new Error(\n        \"Search queries must always be in relevance order. Can not set order manually.\"\n      );\n    }\n    if (query.source.order !== null) {\n      throw new Error(\"Queries may only specify order at most once\");\n    }\n    query.source.order = order;\n    return new QueryImpl(query);\n  }\n  filter(predicate) {\n    validateArg(predicate, 1, \"filter\", \"predicate\");\n    const query = this.takeQuery();\n    if (query.operators.length >= MAX_QUERY_OPERATORS) {\n      throw new Error(\n        `Can't construct query with more than ${MAX_QUERY_OPERATORS} operators`\n      );\n    }\n    query.operators.push({\n      filter: serializeExpression(predicate(filterBuilderImpl))\n    });\n    return new QueryImpl(query);\n  }\n  limit(n) {\n    validateArg(n, 1, \"limit\", \"n\");\n    const query = this.takeQuery();\n    query.operators.push({ limit: n });\n    return new QueryImpl(query);\n  }\n  [Symbol.asyncIterator]() {\n    this.startQuery();\n    return this;\n  }\n  async next() {\n    if (this.state.type === \"closed\" || this.state.type === \"consumed\") {\n      throwClosedError(this.state.type);\n    }\n    const queryId = this.state.type === \"preparing\" ? this.startQuery() : this.state.queryId;\n    const { value, done } = await performAsyncSyscall(\"1.0/queryStreamNext\", {\n      queryId\n    });\n    if (done) {\n      this.closeQuery();\n    }\n    const convexValue = jsonToConvex(value);\n    return { value: convexValue, done };\n  }\n  return() {\n    this.closeQuery();\n    return Promise.resolve({ done: true, value: void 0 });\n  }\n  async paginate(paginationOpts) {\n    validateArg(paginationOpts, 1, \"paginate\", \"options\");\n    if (typeof paginationOpts?.numItems !== \"number\" || paginationOpts.numItems < 0) {\n      throw new Error(\n        `\\`options.numItems\\` must be a positive number. Received \\`${paginationOpts?.numItems}\\`.`\n      );\n    }\n    const query = this.takeQuery();\n    const pageSize = paginationOpts.numItems;\n    const cursor = paginationOpts.cursor;\n    const endCursor = paginationOpts?.endCursor ?? null;\n    const maximumRowsRead = paginationOpts.maximumRowsRead ?? null;\n    const { page, isDone, continueCursor, splitCursor, pageStatus } = await performAsyncSyscall(\"1.0/queryPage\", {\n      query,\n      cursor,\n      endCursor,\n      pageSize,\n      maximumRowsRead,\n      maximumBytesRead: paginationOpts.maximumBytesRead,\n      version\n    });\n    return {\n      page: page.map((json) => jsonToConvex(json)),\n      isDone,\n      continueCursor,\n      splitCursor,\n      pageStatus\n    };\n  }\n  async collect() {\n    const out = [];\n    for await (const item of this) {\n      out.push(item);\n    }\n    return out;\n  }\n  async take(n) {\n    validateArg(n, 1, \"take\", \"n\");\n    validateArgIsNonNegativeInteger(n, 1, \"take\", \"n\");\n    return this.limit(n).collect();\n  }\n  async first() {\n    const first_array = await this.take(1);\n    return first_array.length === 0 ? null : first_array[0];\n  }\n  async unique() {\n    const first_two_array = await this.take(2);\n    if (first_two_array.length === 0) {\n      return null;\n    }\n    if (first_two_array.length === 2) {\n      throw new Error(`unique() query returned more than one result from table ${this.tableNameForErrorMessages}:\n [${first_two_array[0]._id}, ${first_two_array[1]._id}, ...]`);\n    }\n    return first_two_array[0];\n  }\n}\n//# sourceMappingURL=query_impl.js.map\n","\"use strict\";\nimport {\n  convexToJson,\n  jsonToConvex\n} from \"../../values/index.js\";\nimport { performAsyncSyscall, performSyscall } from \"./syscall.js\";\nimport { QueryInitializerImpl } from \"./query_impl.js\";\nimport { validateArg } from \"./validate.js\";\nimport { version } from \"../../index.js\";\nimport { patchValueToJson } from \"../../values/value.js\";\nasync function get(table, id, isSystem) {\n  validateArg(id, 1, \"get\", \"id\");\n  if (typeof id !== \"string\") {\n    throw new Error(\n      `Invalid argument \\`id\\` for \\`db.get\\`, expected string but got '${typeof id}': ${id}`\n    );\n  }\n  const args = {\n    id: convexToJson(id),\n    isSystem,\n    version,\n    table\n  };\n  const syscallJSON = await performAsyncSyscall(\"1.0/get\", args);\n  return jsonToConvex(syscallJSON);\n}\nexport function setupReader() {\n  const reader = (isSystem = false) => {\n    return {\n      get: async (arg0, arg1) => {\n        return arg1 !== void 0 ? await get(arg0, arg1, isSystem) : await get(void 0, arg0, isSystem);\n      },\n      query: (tableName) => {\n        return new TableReader(tableName, isSystem).query();\n      },\n      normalizeId: (tableName, id) => {\n        validateArg(tableName, 1, \"normalizeId\", \"tableName\");\n        validateArg(id, 2, \"normalizeId\", \"id\");\n        const accessingSystemTable = tableName.startsWith(\"_\");\n        if (accessingSystemTable !== isSystem) {\n          throw new Error(\n            `${accessingSystemTable ? \"System\" : \"User\"} tables can only be accessed from db.${isSystem ? \"\" : \"system.\"}normalizeId().`\n          );\n        }\n        const syscallJSON = performSyscall(\"1.0/db/normalizeId\", {\n          table: tableName,\n          idString: id\n        });\n        const syscallResult = jsonToConvex(syscallJSON);\n        return syscallResult.id;\n      },\n      // We set the system reader on the next line\n      system: null,\n      table: (tableName) => {\n        return new TableReader(tableName, isSystem);\n      }\n    };\n  };\n  const { system: _, ...rest } = reader(true);\n  const r = reader();\n  r.system = rest;\n  return r;\n}\nasync function insert(tableName, value) {\n  if (tableName.startsWith(\"_\")) {\n    throw new Error(\"System tables (prefixed with `_`) are read-only.\");\n  }\n  validateArg(tableName, 1, \"insert\", \"table\");\n  validateArg(value, 2, \"insert\", \"value\");\n  const syscallJSON = await performAsyncSyscall(\"1.0/insert\", {\n    table: tableName,\n    value: convexToJson(value)\n  });\n  const syscallResult = jsonToConvex(syscallJSON);\n  return syscallResult._id;\n}\nasync function patch(table, id, value) {\n  validateArg(id, 1, \"patch\", \"id\");\n  validateArg(value, 2, \"patch\", \"value\");\n  await performAsyncSyscall(\"1.0/shallowMerge\", {\n    id: convexToJson(id),\n    value: patchValueToJson(value),\n    table\n  });\n}\nasync function replace(table, id, value) {\n  validateArg(id, 1, \"replace\", \"id\");\n  validateArg(value, 2, \"replace\", \"value\");\n  await performAsyncSyscall(\"1.0/replace\", {\n    id: convexToJson(id),\n    value: convexToJson(value),\n    table\n  });\n}\nasync function delete_(table, id) {\n  validateArg(id, 1, \"delete\", \"id\");\n  await performAsyncSyscall(\"1.0/remove\", {\n    id: convexToJson(id),\n    table\n  });\n}\nexport function setupWriter() {\n  const reader = setupReader();\n  return {\n    get: reader.get,\n    query: reader.query,\n    normalizeId: reader.normalizeId,\n    system: reader.system,\n    insert: async (table, value) => {\n      return await insert(table, value);\n    },\n    patch: async (arg0, arg1, arg2) => {\n      return arg2 !== void 0 ? await patch(arg0, arg1, arg2) : await patch(void 0, arg0, arg1);\n    },\n    replace: async (arg0, arg1, arg2) => {\n      return arg2 !== void 0 ? await replace(arg0, arg1, arg2) : await replace(void 0, arg0, arg1);\n    },\n    delete: async (arg0, arg1) => {\n      return arg1 !== void 0 ? await delete_(arg0, arg1) : await delete_(void 0, arg0);\n    },\n    table: (tableName) => {\n      return new TableWriter(tableName, false);\n    }\n  };\n}\nclass TableReader {\n  constructor(tableName, isSystem) {\n    this.tableName = tableName;\n    this.isSystem = isSystem;\n  }\n  async get(id) {\n    return get(this.tableName, id, this.isSystem);\n  }\n  query() {\n    const accessingSystemTable = this.tableName.startsWith(\"_\");\n    if (accessingSystemTable !== this.isSystem) {\n      throw new Error(\n        `${accessingSystemTable ? \"System\" : \"User\"} tables can only be accessed from db.${this.isSystem ? \"\" : \"system.\"}query().`\n      );\n    }\n    return new QueryInitializerImpl(this.tableName);\n  }\n}\nclass TableWriter extends TableReader {\n  async insert(value) {\n    return insert(this.tableName, value);\n  }\n  async patch(id, value) {\n    return patch(this.tableName, id, value);\n  }\n  async replace(id, value) {\n    return replace(this.tableName, id, value);\n  }\n  async delete(id) {\n    return delete_(this.tableName, id);\n  }\n}\n//# sourceMappingURL=database_impl.js.map\n","\"use strict\";\nimport { convexToJson } from \"../../values/index.js\";\nimport { version } from \"../../index.js\";\nimport { performAsyncSyscall } from \"./syscall.js\";\nimport { parseArgs } from \"../../common/index.js\";\nimport { validateArg } from \"./validate.js\";\nimport { getFunctionAddress } from \"../components/paths.js\";\nexport function setupMutationScheduler() {\n  return {\n    runAfter: async (delayMs, functionReference, args) => {\n      const syscallArgs = runAfterSyscallArgs(delayMs, functionReference, args);\n      return await performAsyncSyscall(\"1.0/schedule\", syscallArgs);\n    },\n    runAt: async (ms_since_epoch_or_date, functionReference, args) => {\n      const syscallArgs = runAtSyscallArgs(\n        ms_since_epoch_or_date,\n        functionReference,\n        args\n      );\n      return await performAsyncSyscall(\"1.0/schedule\", syscallArgs);\n    },\n    cancel: async (id) => {\n      validateArg(id, 1, \"cancel\", \"id\");\n      const args = { id: convexToJson(id) };\n      await performAsyncSyscall(\"1.0/cancel_job\", args);\n    }\n  };\n}\nexport function setupActionScheduler(requestId) {\n  return {\n    runAfter: async (delayMs, functionReference, args) => {\n      const syscallArgs = {\n        requestId,\n        ...runAfterSyscallArgs(delayMs, functionReference, args)\n      };\n      return await performAsyncSyscall(\"1.0/actions/schedule\", syscallArgs);\n    },\n    runAt: async (ms_since_epoch_or_date, functionReference, args) => {\n      const syscallArgs = {\n        requestId,\n        ...runAtSyscallArgs(ms_since_epoch_or_date, functionReference, args)\n      };\n      return await performAsyncSyscall(\"1.0/actions/schedule\", syscallArgs);\n    },\n    cancel: async (id) => {\n      validateArg(id, 1, \"cancel\", \"id\");\n      const syscallArgs = { id: convexToJson(id) };\n      return await performAsyncSyscall(\"1.0/actions/cancel_job\", syscallArgs);\n    }\n  };\n}\nfunction runAfterSyscallArgs(delayMs, functionReference, args) {\n  if (typeof delayMs !== \"number\") {\n    throw new Error(\"`delayMs` must be a number\");\n  }\n  if (!isFinite(delayMs)) {\n    throw new Error(\"`delayMs` must be a finite number\");\n  }\n  if (delayMs < 0) {\n    throw new Error(\"`delayMs` must be non-negative\");\n  }\n  const functionArgs = parseArgs(args);\n  const address = getFunctionAddress(functionReference);\n  const ts = (Date.now() + delayMs) / 1e3;\n  return {\n    ...address,\n    ts,\n    args: convexToJson(functionArgs),\n    version\n  };\n}\nfunction runAtSyscallArgs(ms_since_epoch_or_date, functionReference, args) {\n  let ts;\n  if (ms_since_epoch_or_date instanceof Date) {\n    ts = ms_since_epoch_or_date.valueOf() / 1e3;\n  } else if (typeof ms_since_epoch_or_date === \"number\") {\n    ts = ms_since_epoch_or_date / 1e3;\n  } else {\n    throw new Error(\"The invoke time must a Date or a timestamp\");\n  }\n  const address = getFunctionAddress(functionReference);\n  const functionArgs = parseArgs(args);\n  return {\n    ...address,\n    ts,\n    args: convexToJson(functionArgs),\n    version\n  };\n}\n//# sourceMappingURL=scheduler_impl.js.map\n","\"use strict\";\nimport { version } from \"../../index.js\";\nimport { performAsyncSyscall, performJsSyscall } from \"./syscall.js\";\nimport { validateArg } from \"./validate.js\";\nexport function setupStorageReader(requestId) {\n  return {\n    getUrl: async (storageId) => {\n      validateArg(storageId, 1, \"getUrl\", \"storageId\");\n      return await performAsyncSyscall(\"1.0/storageGetUrl\", {\n        requestId,\n        version,\n        storageId\n      });\n    },\n    getMetadata: async (storageId) => {\n      return await performAsyncSyscall(\"1.0/storageGetMetadata\", {\n        requestId,\n        version,\n        storageId\n      });\n    }\n  };\n}\nexport function setupStorageWriter(requestId) {\n  const reader = setupStorageReader(requestId);\n  return {\n    generateUploadUrl: async () => {\n      return await performAsyncSyscall(\"1.0/storageGenerateUploadUrl\", {\n        requestId,\n        version\n      });\n    },\n    delete: async (storageId) => {\n      await performAsyncSyscall(\"1.0/storageDelete\", {\n        requestId,\n        version,\n        storageId\n      });\n    },\n    getUrl: reader.getUrl,\n    getMetadata: reader.getMetadata\n  };\n}\nexport function setupStorageActionWriter(requestId) {\n  const writer = setupStorageWriter(requestId);\n  return {\n    ...writer,\n    store: async (blob, options) => {\n      return await performJsSyscall(\"storage/storeBlob\", {\n        requestId,\n        version,\n        blob,\n        options\n      });\n    },\n    get: async (storageId) => {\n      return await performJsSyscall(\"storage/getBlob\", {\n        requestId,\n        version,\n        storageId\n      });\n    }\n  };\n}\n//# sourceMappingURL=storage_impl.js.map\n","\"use strict\";\nimport {\n  convexToJson,\n  jsonToConvex,\n  v\n} from \"../../values/index.js\";\nimport { setupActionCalls } from \"./actions_impl.js\";\nimport { setupActionVectorSearch } from \"./vector_search_impl.js\";\nimport { setupAuth } from \"./authentication_impl.js\";\nimport { setupReader, setupWriter } from \"./database_impl.js\";\nimport { QueryImpl, QueryInitializerImpl } from \"./query_impl.js\";\nimport {\n  setupActionScheduler,\n  setupMutationScheduler\n} from \"./scheduler_impl.js\";\nimport {\n  setupStorageActionWriter,\n  setupStorageReader,\n  setupStorageWriter\n} from \"./storage_impl.js\";\nimport { parseArgs } from \"../../common/index.js\";\nimport { performAsyncSyscall } from \"./syscall.js\";\nimport { asObjectValidator } from \"../../values/validator.js\";\nimport { getFunctionAddress } from \"../components/paths.js\";\nasync function invokeMutation(func, argsStr) {\n  const requestId = \"\";\n  const args = jsonToConvex(JSON.parse(argsStr));\n  const mutationCtx = {\n    db: setupWriter(),\n    auth: setupAuth(requestId),\n    storage: setupStorageWriter(requestId),\n    scheduler: setupMutationScheduler(),\n    runQuery: (reference, args2) => runUdf(\"query\", reference, args2),\n    runMutation: (reference, args2) => runUdf(\"mutation\", reference, args2)\n  };\n  const result = await invokeFunction(func, mutationCtx, args);\n  validateReturnValue(result);\n  return JSON.stringify(convexToJson(result === void 0 ? null : result));\n}\nexport function validateReturnValue(v2) {\n  if (v2 instanceof QueryInitializerImpl || v2 instanceof QueryImpl) {\n    throw new Error(\n      \"Return value is a Query. Results must be retrieved with `.collect()`, `.take(n), `.unique()`, or `.first()`.\"\n    );\n  }\n}\nexport async function invokeFunction(func, ctx, args) {\n  let result;\n  try {\n    result = await Promise.resolve(func(ctx, ...args));\n  } catch (thrown) {\n    throw serializeConvexErrorData(thrown);\n  }\n  return result;\n}\nfunction dontCallDirectly(funcType, handler) {\n  return (ctx, args) => {\n    globalThis.console.warn(\n      `Convex functions should not directly call other Convex functions. Consider calling a helper function instead. e.g. \\`export const foo = ${funcType}(...); await foo(ctx);\\` is not supported. See https://docs.convex.dev/production/best-practices/#use-helper-functions-to-write-shared-code`\n    );\n    return handler(ctx, args);\n  };\n}\nfunction serializeConvexErrorData(thrown) {\n  if (typeof thrown === \"object\" && thrown !== null && Symbol.for(\"ConvexError\") in thrown) {\n    const error = thrown;\n    error.data = JSON.stringify(\n      convexToJson(error.data === void 0 ? null : error.data)\n    );\n    error.ConvexErrorSymbol = Symbol.for(\"ConvexError\");\n    return error;\n  } else {\n    return thrown;\n  }\n}\nfunction assertNotBrowser() {\n  if (typeof window === \"undefined\" || window.__convexAllowFunctionsInBrowser) {\n    return;\n  }\n  const isRealBrowser = Object.getOwnPropertyDescriptor(globalThis, \"window\")?.get?.toString().includes(\"[native code]\") ?? false;\n  if (isRealBrowser) {\n    console.error(\n      \"Convex functions should not be imported in the browser. This will throw an error in future versions of `convex`. If this is a false negative, please report it to Convex support.\"\n    );\n  }\n}\nfunction strictReplacer(key, value) {\n  if (value === void 0) {\n    throw new Error(\n      `A validator is undefined for field \"${key}\". This is often caused by circular imports. See https://docs.convex.dev/error#undefined-validator for details.`\n    );\n  }\n  return value;\n}\nfunction exportArgs(functionDefinition) {\n  return () => {\n    let args = v.any();\n    if (typeof functionDefinition === \"object\" && functionDefinition.args !== void 0) {\n      args = asObjectValidator(functionDefinition.args);\n    }\n    return JSON.stringify(args.json, strictReplacer);\n  };\n}\nfunction exportReturns(functionDefinition) {\n  return () => {\n    let returns;\n    if (typeof functionDefinition === \"object\" && functionDefinition.returns !== void 0) {\n      returns = asObjectValidator(functionDefinition.returns);\n    }\n    return JSON.stringify(returns ? returns.json : null, strictReplacer);\n  };\n}\nexport const mutationGeneric = ((functionDefinition) => {\n  const handler = typeof functionDefinition === \"function\" ? functionDefinition : functionDefinition.handler;\n  const func = dontCallDirectly(\"mutation\", handler);\n  assertNotBrowser();\n  func.isMutation = true;\n  func.isPublic = true;\n  func.invokeMutation = (argsStr) => invokeMutation(handler, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  func.exportReturns = exportReturns(functionDefinition);\n  func._handler = handler;\n  return func;\n});\nexport const internalMutationGeneric = ((functionDefinition) => {\n  const handler = typeof functionDefinition === \"function\" ? functionDefinition : functionDefinition.handler;\n  const func = dontCallDirectly(\n    \"internalMutation\",\n    handler\n  );\n  assertNotBrowser();\n  func.isMutation = true;\n  func.isInternal = true;\n  func.invokeMutation = (argsStr) => invokeMutation(handler, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  func.exportReturns = exportReturns(functionDefinition);\n  func._handler = handler;\n  return func;\n});\nasync function invokeQuery(func, argsStr) {\n  const requestId = \"\";\n  const args = jsonToConvex(JSON.parse(argsStr));\n  const queryCtx = {\n    db: setupReader(),\n    auth: setupAuth(requestId),\n    storage: setupStorageReader(requestId),\n    runQuery: (reference, args2) => runUdf(\"query\", reference, args2)\n  };\n  const result = await invokeFunction(func, queryCtx, args);\n  validateReturnValue(result);\n  return JSON.stringify(convexToJson(result === void 0 ? null : result));\n}\nexport const queryGeneric = ((functionDefinition) => {\n  const handler = typeof functionDefinition === \"function\" ? functionDefinition : functionDefinition.handler;\n  const func = dontCallDirectly(\"query\", handler);\n  assertNotBrowser();\n  func.isQuery = true;\n  func.isPublic = true;\n  func.invokeQuery = (argsStr) => invokeQuery(handler, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  func.exportReturns = exportReturns(functionDefinition);\n  func._handler = handler;\n  return func;\n});\nexport const internalQueryGeneric = ((functionDefinition) => {\n  const handler = typeof functionDefinition === \"function\" ? functionDefinition : functionDefinition.handler;\n  const func = dontCallDirectly(\"internalQuery\", handler);\n  assertNotBrowser();\n  func.isQuery = true;\n  func.isInternal = true;\n  func.invokeQuery = (argsStr) => invokeQuery(handler, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  func.exportReturns = exportReturns(functionDefinition);\n  func._handler = handler;\n  return func;\n});\nasync function invokeAction(func, requestId, argsStr) {\n  const args = jsonToConvex(JSON.parse(argsStr));\n  const calls = setupActionCalls(requestId);\n  const ctx = {\n    ...calls,\n    auth: setupAuth(requestId),\n    scheduler: setupActionScheduler(requestId),\n    storage: setupStorageActionWriter(requestId),\n    vectorSearch: setupActionVectorSearch(requestId)\n  };\n  const result = await invokeFunction(func, ctx, args);\n  return JSON.stringify(convexToJson(result === void 0 ? null : result));\n}\nexport const actionGeneric = ((functionDefinition) => {\n  const handler = typeof functionDefinition === \"function\" ? functionDefinition : functionDefinition.handler;\n  const func = dontCallDirectly(\"action\", handler);\n  assertNotBrowser();\n  func.isAction = true;\n  func.isPublic = true;\n  func.invokeAction = (requestId, argsStr) => invokeAction(handler, requestId, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  func.exportReturns = exportReturns(functionDefinition);\n  func._handler = handler;\n  return func;\n});\nexport const internalActionGeneric = ((functionDefinition) => {\n  const handler = typeof functionDefinition === \"function\" ? functionDefinition : functionDefinition.handler;\n  const func = dontCallDirectly(\"internalAction\", handler);\n  assertNotBrowser();\n  func.isAction = true;\n  func.isInternal = true;\n  func.invokeAction = (requestId, argsStr) => invokeAction(handler, requestId, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  func.exportReturns = exportReturns(functionDefinition);\n  func._handler = handler;\n  return func;\n});\nasync function invokeHttpAction(func, request) {\n  const requestId = \"\";\n  const calls = setupActionCalls(requestId);\n  const ctx = {\n    ...calls,\n    auth: setupAuth(requestId),\n    storage: setupStorageActionWriter(requestId),\n    scheduler: setupActionScheduler(requestId),\n    vectorSearch: setupActionVectorSearch(requestId)\n  };\n  return await invokeFunction(func, ctx, [request]);\n}\nexport const httpActionGeneric = (func) => {\n  const q = dontCallDirectly(\"httpAction\", func);\n  assertNotBrowser();\n  q.isHttp = true;\n  q.invokeHttpAction = (request) => invokeHttpAction(func, request);\n  q._handler = func;\n  return q;\n};\nasync function runUdf(udfType, f, args) {\n  const queryArgs = parseArgs(args);\n  const syscallArgs = {\n    udfType,\n    args: convexToJson(queryArgs),\n    ...getFunctionAddress(f)\n  };\n  const result = await performAsyncSyscall(\"1.0/runUdf\", syscallArgs);\n  return jsonToConvex(result);\n}\n//# sourceMappingURL=registration_impl.js.map\n","\"use strict\";\nimport { v } from \"../values/validator.js\";\nexport const paginationOptsValidator = v.object({\n  numItems: v.number(),\n  cursor: v.union(v.string(), v.null()),\n  endCursor: v.optional(v.union(v.string(), v.null())),\n  id: v.optional(v.number()),\n  maximumRowsRead: v.optional(v.number()),\n  maximumBytesRead: v.optional(v.number())\n});\nexport function paginationResultValidator(itemValidator) {\n  return v.object({\n    page: v.array(itemValidator),\n    continueCursor: v.string(),\n    isDone: v.boolean(),\n    splitCursor: v.optional(v.union(v.string(), v.null())),\n    pageStatus: v.optional(\n      v.union(\n        v.literal(\"SplitRecommended\"),\n        v.literal(\"SplitRequired\"),\n        v.null()\n      )\n    )\n  });\n}\n//# sourceMappingURL=pagination.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { getFunctionName } from \"../server/api.js\";\nimport { parseArgs } from \"../common/index.js\";\nimport { convexToJson } from \"../values/index.js\";\nconst DAYS_OF_WEEK = [\n  \"sunday\",\n  \"monday\",\n  \"tuesday\",\n  \"wednesday\",\n  \"thursday\",\n  \"friday\",\n  \"saturday\"\n];\nexport const cronJobs = () => new Crons();\nfunction validateIntervalNumber(n) {\n  if (!Number.isInteger(n) || n <= 0) {\n    throw new Error(\"Interval must be an integer greater than 0\");\n  }\n}\nfunction validatedDayOfMonth(n) {\n  if (!Number.isInteger(n) || n < 1 || n > 31) {\n    throw new Error(\"Day of month must be an integer from 1 to 31\");\n  }\n  return n;\n}\nfunction validatedDayOfWeek(s) {\n  if (!DAYS_OF_WEEK.includes(s)) {\n    throw new Error('Day of week must be a string like \"monday\".');\n  }\n  return s;\n}\nfunction validatedHourOfDay(n) {\n  if (!Number.isInteger(n) || n < 0 || n > 23) {\n    throw new Error(\"Hour of day must be an integer from 0 to 23\");\n  }\n  return n;\n}\nfunction validatedMinuteOfHour(n) {\n  if (!Number.isInteger(n) || n < 0 || n > 59) {\n    throw new Error(\"Minute of hour must be an integer from 0 to 59\");\n  }\n  return n;\n}\nfunction validatedCronString(s) {\n  return s;\n}\nfunction validatedCronIdentifier(s) {\n  if (!s.match(/^[ -~]*$/)) {\n    throw new Error(\n      `Invalid cron identifier ${s}: use ASCII letters that are not control characters`\n    );\n  }\n  return s;\n}\nexport class Crons {\n  constructor() {\n    __publicField(this, \"crons\");\n    __publicField(this, \"isCrons\");\n    this.isCrons = true;\n    this.crons = {};\n  }\n  /** @internal */\n  schedule(cronIdentifier, schedule, functionReference, args) {\n    const cronArgs = parseArgs(args);\n    validatedCronIdentifier(cronIdentifier);\n    if (cronIdentifier in this.crons) {\n      throw new Error(`Cron identifier registered twice: ${cronIdentifier}`);\n    }\n    this.crons[cronIdentifier] = {\n      name: getFunctionName(functionReference),\n      args: [convexToJson(cronArgs)],\n      schedule\n    };\n  }\n  /**\n   * Schedule a mutation or action to run at some interval.\n   *\n   * ```js\n   * crons.interval(\"Clear presence data\", {seconds: 30}, api.presence.clear);\n   * ```\n   *\n   * @param identifier - A unique name for this scheduled job.\n   * @param schedule - The time between runs for this scheduled job.\n   * @param functionReference - A {@link FunctionReference} for the function\n   * to schedule.\n   * @param args - The arguments to the function.\n   */\n  interval(cronIdentifier, schedule, functionReference, ...args) {\n    const s = schedule;\n    const hasSeconds = +(\"seconds\" in s && s.seconds !== void 0);\n    const hasMinutes = +(\"minutes\" in s && s.minutes !== void 0);\n    const hasHours = +(\"hours\" in s && s.hours !== void 0);\n    const total = hasSeconds + hasMinutes + hasHours;\n    if (total !== 1) {\n      throw new Error(\"Must specify one of seconds, minutes, or hours\");\n    }\n    if (hasSeconds) {\n      validateIntervalNumber(schedule.seconds);\n    } else if (hasMinutes) {\n      validateIntervalNumber(schedule.minutes);\n    } else if (hasHours) {\n      validateIntervalNumber(schedule.hours);\n    }\n    this.schedule(\n      cronIdentifier,\n      { ...schedule, type: \"interval\" },\n      functionReference,\n      ...args\n    );\n  }\n  /**\n   * Schedule a mutation or action to run on an hourly basis.\n   *\n   * ```js\n   * crons.hourly(\n   *   \"Reset high scores\",\n   *   {\n   *     minuteUTC: 30,\n   *   },\n   *   api.scores.reset\n   * )\n   * ```\n   *\n   * @param cronIdentifier - A unique name for this scheduled job.\n   * @param schedule - What time (UTC) each day to run this function.\n   * @param functionReference - A {@link FunctionReference} for the function\n   * to schedule.\n   * @param args - The arguments to the function.\n   */\n  hourly(cronIdentifier, schedule, functionReference, ...args) {\n    const minuteUTC = validatedMinuteOfHour(schedule.minuteUTC);\n    this.schedule(\n      cronIdentifier,\n      { minuteUTC, type: \"hourly\" },\n      functionReference,\n      ...args\n    );\n  }\n  /**\n   * Schedule a mutation or action to run on a daily basis.\n   *\n   * ```js\n   * crons.daily(\n   *   \"Reset high scores\",\n   *   {\n   *     hourUTC: 17, // (9:30am Pacific/10:30am Daylight Savings Pacific)\n   *     minuteUTC: 30,\n   *   },\n   *   api.scores.reset\n   * )\n   * ```\n   *\n   * @param cronIdentifier - A unique name for this scheduled job.\n   * @param schedule - What time (UTC) each day to run this function.\n   * @param functionReference - A {@link FunctionReference} for the function\n   * to schedule.\n   * @param args - The arguments to the function.\n   */\n  daily(cronIdentifier, schedule, functionReference, ...args) {\n    const hourUTC = validatedHourOfDay(schedule.hourUTC);\n    const minuteUTC = validatedMinuteOfHour(schedule.minuteUTC);\n    this.schedule(\n      cronIdentifier,\n      { hourUTC, minuteUTC, type: \"daily\" },\n      functionReference,\n      ...args\n    );\n  }\n  /**\n   * Schedule a mutation or action to run on a weekly basis.\n   *\n   * ```js\n   * crons.weekly(\n   *   \"Weekly re-engagement email\",\n   *   {\n   *     dayOfWeek: \"Tuesday\",\n   *     hourUTC: 17, // (9:30am Pacific/10:30am Daylight Savings Pacific)\n   *     minuteUTC: 30,\n   *   },\n   *   api.emails.send\n   * )\n   * ```\n   *\n   * @param cronIdentifier - A unique name for this scheduled job.\n   * @param schedule - What day and time (UTC) each week to run this function.\n   * @param functionReference - A {@link FunctionReference} for the function\n   * to schedule.\n   */\n  weekly(cronIdentifier, schedule, functionReference, ...args) {\n    const dayOfWeek = validatedDayOfWeek(schedule.dayOfWeek);\n    const hourUTC = validatedHourOfDay(schedule.hourUTC);\n    const minuteUTC = validatedMinuteOfHour(schedule.minuteUTC);\n    this.schedule(\n      cronIdentifier,\n      { dayOfWeek, hourUTC, minuteUTC, type: \"weekly\" },\n      functionReference,\n      ...args\n    );\n  }\n  /**\n   * Schedule a mutation or action to run on a monthly basis.\n   *\n   * Note that some months have fewer days than others, so e.g. a function\n   * scheduled to run on the 30th will not run in February.\n   *\n   * ```js\n   * crons.monthly(\n   *   \"Bill customers at \",\n   *   {\n   *     hourUTC: 17, // (9:30am Pacific/10:30am Daylight Savings Pacific)\n   *     minuteUTC: 30,\n   *     day: 1,\n   *   },\n   *   api.billing.billCustomers\n   * )\n   * ```\n   *\n   * @param cronIdentifier - A unique name for this scheduled job.\n   * @param schedule - What day and time (UTC) each month to run this function.\n   * @param functionReference - A {@link FunctionReference} for the function\n   * to schedule.\n   * @param args - The arguments to the function.\n   */\n  monthly(cronIdentifier, schedule, functionReference, ...args) {\n    const day = validatedDayOfMonth(schedule.day);\n    const hourUTC = validatedHourOfDay(schedule.hourUTC);\n    const minuteUTC = validatedMinuteOfHour(schedule.minuteUTC);\n    this.schedule(\n      cronIdentifier,\n      { day, hourUTC, minuteUTC, type: \"monthly\" },\n      functionReference,\n      ...args\n    );\n  }\n  /**\n   * Schedule a mutation or action to run on a recurring basis.\n   *\n   * Like the unix command `cron`, Sunday is 0, Monday is 1, etc.\n   *\n   * ```\n   *   minute (0 - 59)\n   *    hour (0 - 23)\n   *     day of the month (1 - 31)\n   *      month (1 - 12)\n   *       day of the week (0 - 6) (Sunday to Saturday)\n   * \"* * * * *\"\n   * ```\n   *\n   * @param cronIdentifier - A unique name for this scheduled job.\n   * @param cron - Cron string like `\"15 7 * * *\"` (Every day at 7:15 UTC)\n   * @param functionReference - A {@link FunctionReference} for the function\n   * to schedule.\n   * @param args - The arguments to the function.\n   */\n  cron(cronIdentifier, cron, functionReference, ...args) {\n    const c = validatedCronString(cron);\n    this.schedule(\n      cronIdentifier,\n      { cron: c, type: \"cron\" },\n      functionReference,\n      ...args\n    );\n  }\n  /** @internal */\n  export() {\n    return JSON.stringify(this.crons);\n  }\n}\n//# sourceMappingURL=cron.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { performJsSyscall } from \"./impl/syscall.js\";\nexport const ROUTABLE_HTTP_METHODS = [\n  \"GET\",\n  \"POST\",\n  \"PUT\",\n  \"DELETE\",\n  \"OPTIONS\",\n  \"PATCH\"\n];\nexport function normalizeMethod(method) {\n  if (method === \"HEAD\") return \"GET\";\n  return method;\n}\nexport const httpRouter = () => new HttpRouter();\nexport class HttpRouter {\n  constructor() {\n    __publicField(this, \"exactRoutes\", /* @__PURE__ */ new Map());\n    __publicField(this, \"prefixRoutes\", /* @__PURE__ */ new Map());\n    __publicField(this, \"isRouter\", true);\n    /**\n     * Specify an HttpAction to be used to respond to requests\n     * for an HTTP method (e.g. \"GET\") and a path or pathPrefix.\n     *\n     * Paths must begin with a slash. Path prefixes must also end in a slash.\n     *\n     * ```js\n     * // matches `/profile` (but not `/profile/`)\n     * http.route({ path: \"/profile\", method: \"GET\", handler: getProfile})\n     *\n     * // matches `/profiles/`, `/profiles/abc`, and `/profiles/a/c/b` (but not `/profile`)\n     * http.route({ pathPrefix: \"/profile/\", method: \"GET\", handler: getProfile})\n     * ```\n     */\n    __publicField(this, \"route\", (spec) => {\n      if (!spec.handler) throw new Error(`route requires handler`);\n      if (!spec.method) throw new Error(`route requires method`);\n      const { method, handler } = spec;\n      if (!ROUTABLE_HTTP_METHODS.includes(method)) {\n        throw new Error(\n          `'${method}' is not an allowed HTTP method (like GET, POST, PUT etc.)`\n        );\n      }\n      if (\"path\" in spec) {\n        if (\"pathPrefix\" in spec) {\n          throw new Error(\n            `Invalid httpRouter route: cannot contain both 'path' and 'pathPrefix'`\n          );\n        }\n        if (!spec.path.startsWith(\"/\")) {\n          throw new Error(`path '${spec.path}' does not start with a /`);\n        }\n        if (spec.path.startsWith(\"/.files/\") || spec.path === \"/.files\") {\n          throw new Error(`path '${spec.path}' is reserved`);\n        }\n        const methods = this.exactRoutes.has(spec.path) ? this.exactRoutes.get(spec.path) : /* @__PURE__ */ new Map();\n        if (methods.has(method)) {\n          throw new Error(\n            `Path '${spec.path}' for method ${method} already in use`\n          );\n        }\n        methods.set(method, handler);\n        this.exactRoutes.set(spec.path, methods);\n      } else if (\"pathPrefix\" in spec) {\n        if (!spec.pathPrefix.startsWith(\"/\")) {\n          throw new Error(\n            `pathPrefix '${spec.pathPrefix}' does not start with a /`\n          );\n        }\n        if (!spec.pathPrefix.endsWith(\"/\")) {\n          throw new Error(`pathPrefix ${spec.pathPrefix} must end with a /`);\n        }\n        if (spec.pathPrefix.startsWith(\"/.files/\")) {\n          throw new Error(`pathPrefix '${spec.pathPrefix}' is reserved`);\n        }\n        const prefixes = this.prefixRoutes.get(method) || /* @__PURE__ */ new Map();\n        if (prefixes.has(spec.pathPrefix)) {\n          throw new Error(\n            `${spec.method} pathPrefix ${spec.pathPrefix} is already defined`\n          );\n        }\n        prefixes.set(spec.pathPrefix, handler);\n        this.prefixRoutes.set(method, prefixes);\n      } else {\n        throw new Error(\n          `Invalid httpRouter route entry: must contain either field 'path' or 'pathPrefix'`\n        );\n      }\n    });\n    /**\n     * Returns a list of routed HTTP actions.\n     *\n     * These are used to populate the list of routes shown in the Functions page of the Convex dashboard.\n     *\n     * @returns - an array of [path, method, endpoint] tuples.\n     */\n    __publicField(this, \"getRoutes\", () => {\n      const exactPaths = [...this.exactRoutes.keys()].sort();\n      const exact = exactPaths.flatMap(\n        (path) => [...this.exactRoutes.get(path).keys()].sort().map(\n          (method) => [path, method, this.exactRoutes.get(path).get(method)]\n        )\n      );\n      const prefixPathMethods = [...this.prefixRoutes.keys()].sort();\n      const prefixes = prefixPathMethods.flatMap(\n        (method) => [...this.prefixRoutes.get(method).keys()].sort().map(\n          (pathPrefix) => [\n            `${pathPrefix}*`,\n            method,\n            this.prefixRoutes.get(method).get(pathPrefix)\n          ]\n        )\n      );\n      return [...exact, ...prefixes];\n    });\n    /**\n     * Returns the appropriate HTTP action and its routed request path and method.\n     *\n     * The path and method returned are used for logging and metrics, and should\n     * match up with one of the routes returned by `getRoutes`.\n     *\n     * For example,\n     *\n     * ```js\n     * http.route({ pathPrefix: \"/profile/\", method: \"GET\", handler: getProfile});\n     *\n     * http.lookup(\"/profile/abc\", \"GET\") // returns [getProfile, \"GET\", \"/profile/*\"]\n     *```\n     *\n     * @returns - a tuple [{@link PublicHttpAction}, method, path] or null.\n     */\n    __publicField(this, \"lookup\", (path, method) => {\n      method = normalizeMethod(method);\n      const exactMatch = this.exactRoutes.get(path)?.get(method);\n      if (exactMatch) return [exactMatch, method, path];\n      const prefixes = this.prefixRoutes.get(method) || /* @__PURE__ */ new Map();\n      const prefixesSorted = [...prefixes.entries()].sort(\n        ([prefixA, _a], [prefixB, _b]) => prefixB.length - prefixA.length\n      );\n      for (const [pathPrefix, endpoint] of prefixesSorted) {\n        if (path.startsWith(pathPrefix)) {\n          return [endpoint, method, `${pathPrefix}*`];\n        }\n      }\n      return null;\n    });\n    /**\n     * Given a JSON string representation of a Request object, return a Response\n     * by routing the request and running the appropriate endpoint or returning\n     * a 404 Response.\n     *\n     * @param argsStr - a JSON string representing a Request object.\n     *\n     * @returns - a Response object.\n     */\n    __publicField(this, \"runRequest\", async (argsStr, requestRoute) => {\n      const request = performJsSyscall(\"requestFromConvexJson\", {\n        convexJson: JSON.parse(argsStr)\n      });\n      let pathname = requestRoute;\n      if (!pathname || typeof pathname !== \"string\") {\n        pathname = new URL(request.url).pathname;\n      }\n      const method = request.method;\n      const match = this.lookup(pathname, method);\n      if (!match) {\n        const response2 = new Response(`No HttpAction routed for ${pathname}`, {\n          status: 404\n        });\n        return JSON.stringify(\n          performJsSyscall(\"convexJsonFromResponse\", { response: response2 })\n        );\n      }\n      const [endpoint, _method, _path] = match;\n      const response = await endpoint.invokeHttpAction(request);\n      return JSON.stringify(\n        performJsSyscall(\"convexJsonFromResponse\", { response })\n      );\n    });\n  }\n}\n//# sourceMappingURL=router.js.map\n","\"use strict\";\nimport { convexToJson, jsonToConvex } from \"../../values/index.js\";\nimport { version } from \"../../index.js\";\nimport { performAsyncSyscall } from \"./syscall.js\";\nimport { parseArgs } from \"../../common/index.js\";\nimport { getFunctionAddress } from \"../components/paths.js\";\nfunction syscallArgs(requestId, functionReference, args) {\n  const address = getFunctionAddress(functionReference);\n  return {\n    ...address,\n    args: convexToJson(parseArgs(args)),\n    version,\n    requestId\n  };\n}\nexport function setupActionCalls(requestId) {\n  return {\n    runQuery: async (query, args) => {\n      const result = await performAsyncSyscall(\n        \"1.0/actions/query\",\n        syscallArgs(requestId, query, args)\n      );\n      return jsonToConvex(result);\n    },\n    runMutation: async (mutation, args) => {\n      const result = await performAsyncSyscall(\n        \"1.0/actions/mutation\",\n        syscallArgs(requestId, mutation, args)\n      );\n      return jsonToConvex(result);\n    },\n    runAction: async (action, args) => {\n      const result = await performAsyncSyscall(\n        \"1.0/actions/action\",\n        syscallArgs(requestId, action, args)\n      );\n      return jsonToConvex(result);\n    }\n  };\n}\n//# sourceMappingURL=actions_impl.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { convexToJson } from \"../../values/index.js\";\nimport { version } from \"../../index.js\";\nimport { performAsyncSyscall } from \"../impl/syscall.js\";\nimport {\n  getFunctionAddress,\n  setReferencePath,\n  toReferencePath\n} from \"./paths.js\";\nexport { getFunctionAddress } from \"./paths.js\";\nexport async function createFunctionHandle(functionReference) {\n  const address = getFunctionAddress(functionReference);\n  return await performAsyncSyscall(\"1.0/createFunctionHandle\", {\n    ...address,\n    version\n  });\n}\nclass InstalledComponent {\n  constructor(definition, name) {\n    /**\n     * @internal\n     */\n    __publicField(this, \"_definition\");\n    /**\n     * @internal\n     */\n    __publicField(this, \"_name\");\n    this._definition = definition;\n    this._name = name;\n    setReferencePath(this, `_reference/childComponent/${name}`);\n  }\n  get exports() {\n    return createExports(this._name, []);\n  }\n}\nfunction createExports(name, pathParts) {\n  const handler = {\n    get(_, prop) {\n      if (typeof prop === \"string\") {\n        const newParts = [...pathParts, prop];\n        return createExports(name, newParts);\n      } else if (prop === toReferencePath) {\n        let reference = `_reference/childComponent/${name}`;\n        for (const part of pathParts) {\n          reference += `/${part}`;\n        }\n        return reference;\n      } else {\n        return void 0;\n      }\n    }\n  };\n  return new Proxy({}, handler);\n}\nfunction use(definition, options) {\n  const importedComponentDefinition = definition;\n  if (typeof importedComponentDefinition.componentDefinitionPath !== \"string\") {\n    throw new Error(\n      \"Component definition does not have the required componentDefinitionPath property. This code only works in Convex runtime.\"\n    );\n  }\n  const name = options?.name ?? // added recently\n  importedComponentDefinition.defaultName ?? // can be removed once backend is out\n  importedComponentDefinition.componentDefinitionPath.split(\"/\").pop();\n  if (typeof name !== \"string\") {\n    throw new Error(\n      `Component name must be a string. Received: ${typeof name}`\n    );\n  }\n  if (name.length === 0) {\n    throw new Error(\"Component name cannot be empty.\");\n  }\n  this._childComponents.push([name, importedComponentDefinition, {}]);\n  return new InstalledComponent(definition, name);\n}\nfunction exportAppForAnalysis() {\n  const definitionType = { type: \"app\" };\n  const childComponents = serializeChildComponents(this._childComponents);\n  return {\n    definitionType,\n    childComponents,\n    httpMounts: {},\n    exports: serializeExportTree(this._exportTree)\n  };\n}\nfunction serializeExportTree(tree) {\n  const branch = [];\n  for (const [key, child] of Object.entries(tree)) {\n    let node;\n    if (typeof child === \"string\") {\n      node = { type: \"leaf\", leaf: child };\n    } else {\n      node = serializeExportTree(child);\n    }\n    branch.push([key, node]);\n  }\n  return { type: \"branch\", branch };\n}\nfunction serializeChildComponents(childComponents) {\n  return childComponents.map(([name, definition, p]) => {\n    let args = null;\n    if (p !== null) {\n      args = [];\n      for (const [name2, value] of Object.entries(p)) {\n        if (value !== void 0) {\n          args.push([\n            name2,\n            { type: \"value\", value: JSON.stringify(convexToJson(value)) }\n          ]);\n        }\n      }\n    }\n    const path = definition.componentDefinitionPath;\n    if (!path)\n      throw new Error(\n        \"no .componentPath for component definition \" + JSON.stringify(definition, null, 2)\n      );\n    return {\n      name,\n      path,\n      args\n    };\n  });\n}\nfunction exportComponentForAnalysis() {\n  const args = Object.entries(\n    this._args\n  ).map(([name, validator]) => [\n    name,\n    {\n      type: \"value\",\n      value: JSON.stringify(validator.json)\n    }\n  ]);\n  const definitionType = {\n    type: \"childComponent\",\n    name: this._name,\n    args\n  };\n  const childComponents = serializeChildComponents(this._childComponents);\n  return {\n    name: this._name,\n    definitionType,\n    childComponents,\n    httpMounts: {},\n    exports: serializeExportTree(this._exportTree)\n  };\n}\nexport function defineComponent(name) {\n  const ret = {\n    _isRoot: false,\n    _name: name,\n    _args: {},\n    _childComponents: [],\n    _exportTree: {},\n    _onInitCallbacks: {},\n    export: exportComponentForAnalysis,\n    use,\n    // pretend to conform to ComponentDefinition, which temporarily expects __args\n    ...{}\n  };\n  return ret;\n}\nexport function defineApp() {\n  const ret = {\n    _isRoot: true,\n    _childComponents: [],\n    _exportTree: {},\n    export: exportAppForAnalysis,\n    use\n  };\n  return ret;\n}\nexport function currentSystemUdfInComponent(componentId) {\n  return {\n    [toReferencePath]: `_reference/currentSystemUdfInComponent/${componentId}`\n  };\n}\nfunction createChildComponents(root, pathParts) {\n  const handler = {\n    get(_, prop) {\n      if (typeof prop === \"string\") {\n        const newParts = [...pathParts, prop];\n        return createChildComponents(root, newParts);\n      } else if (prop === toReferencePath) {\n        if (pathParts.length < 1) {\n          const found = [root, ...pathParts].join(\".\");\n          throw new Error(\n            `API path is expected to be of the form \\`${root}.childComponent.functionName\\`. Found: \\`${found}\\``\n          );\n        }\n        return `_reference/childComponent/` + pathParts.join(\"/\");\n      } else {\n        return void 0;\n      }\n    }\n  };\n  return new Proxy({}, handler);\n}\nexport const componentsGeneric = () => createChildComponents(\"components\", []);\n//# sourceMappingURL=index.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport {\n  isValidator,\n  v\n} from \"../values/validator.js\";\nexport class TableDefinition {\n  /**\n   * @internal\n   */\n  constructor(documentType) {\n    __publicField(this, \"indexes\");\n    __publicField(this, \"stagedDbIndexes\");\n    __publicField(this, \"searchIndexes\");\n    __publicField(this, \"stagedSearchIndexes\");\n    __publicField(this, \"vectorIndexes\");\n    __publicField(this, \"stagedVectorIndexes\");\n    // The type of documents stored in this table.\n    __publicField(this, \"validator\");\n    this.indexes = [];\n    this.stagedDbIndexes = [];\n    this.searchIndexes = [];\n    this.stagedSearchIndexes = [];\n    this.vectorIndexes = [];\n    this.stagedVectorIndexes = [];\n    this.validator = documentType;\n  }\n  /**\n   * This API is experimental: it may change or disappear.\n   *\n   * Returns indexes defined on this table.\n   * Intended for the advanced use cases of dynamically deciding which index to use for a query.\n   * If you think you need this, please chime in on ths issue in the Convex JS GitHub repo.\n   * https://github.com/get-convex/convex-js/issues/49\n   */\n  \" indexes\"() {\n    return this.indexes;\n  }\n  index(name, indexConfig) {\n    if (Array.isArray(indexConfig)) {\n      this.indexes.push({\n        indexDescriptor: name,\n        fields: indexConfig\n      });\n    } else if (indexConfig.staged) {\n      this.stagedDbIndexes.push({\n        indexDescriptor: name,\n        fields: indexConfig.fields\n      });\n    } else {\n      this.indexes.push({\n        indexDescriptor: name,\n        fields: indexConfig.fields\n      });\n    }\n    return this;\n  }\n  searchIndex(name, indexConfig) {\n    if (indexConfig.staged) {\n      this.stagedSearchIndexes.push({\n        indexDescriptor: name,\n        searchField: indexConfig.searchField,\n        filterFields: indexConfig.filterFields || []\n      });\n    } else {\n      this.searchIndexes.push({\n        indexDescriptor: name,\n        searchField: indexConfig.searchField,\n        filterFields: indexConfig.filterFields || []\n      });\n    }\n    return this;\n  }\n  vectorIndex(name, indexConfig) {\n    if (indexConfig.staged) {\n      this.stagedVectorIndexes.push({\n        indexDescriptor: name,\n        vectorField: indexConfig.vectorField,\n        dimensions: indexConfig.dimensions,\n        filterFields: indexConfig.filterFields || []\n      });\n    } else {\n      this.vectorIndexes.push({\n        indexDescriptor: name,\n        vectorField: indexConfig.vectorField,\n        dimensions: indexConfig.dimensions,\n        filterFields: indexConfig.filterFields || []\n      });\n    }\n    return this;\n  }\n  /**\n   * Work around for https://github.com/microsoft/TypeScript/issues/57035\n   */\n  self() {\n    return this;\n  }\n  /**\n   * Export the contents of this definition.\n   *\n   * This is called internally by the Convex framework.\n   * @internal\n   */\n  export() {\n    const documentType = this.validator.json;\n    if (typeof documentType !== \"object\") {\n      throw new Error(\n        \"Invalid validator: please make sure that the parameter of `defineTable` is valid (see https://docs.convex.dev/database/schemas)\"\n      );\n    }\n    return {\n      indexes: this.indexes,\n      stagedDbIndexes: this.stagedDbIndexes,\n      searchIndexes: this.searchIndexes,\n      stagedSearchIndexes: this.stagedSearchIndexes,\n      vectorIndexes: this.vectorIndexes,\n      stagedVectorIndexes: this.stagedVectorIndexes,\n      documentType\n    };\n  }\n}\nexport function defineTable(documentSchema) {\n  if (isValidator(documentSchema)) {\n    return new TableDefinition(documentSchema);\n  } else {\n    return new TableDefinition(v.object(documentSchema));\n  }\n}\nexport class SchemaDefinition {\n  /**\n   * @internal\n   */\n  constructor(tables, options) {\n    __publicField(this, \"tables\");\n    __publicField(this, \"strictTableNameTypes\");\n    __publicField(this, \"schemaValidation\");\n    this.tables = tables;\n    this.schemaValidation = options?.schemaValidation === void 0 ? true : options.schemaValidation;\n  }\n  /**\n   * Export the contents of this definition.\n   *\n   * This is called internally by the Convex framework.\n   * @internal\n   */\n  export() {\n    return JSON.stringify({\n      tables: Object.entries(this.tables).map(([tableName, definition]) => {\n        const {\n          indexes,\n          stagedDbIndexes,\n          searchIndexes,\n          stagedSearchIndexes,\n          vectorIndexes,\n          stagedVectorIndexes,\n          documentType\n        } = definition.export();\n        return {\n          tableName,\n          indexes,\n          stagedDbIndexes,\n          searchIndexes,\n          stagedSearchIndexes,\n          vectorIndexes,\n          stagedVectorIndexes,\n          documentType\n        };\n      }),\n      schemaValidation: this.schemaValidation\n    });\n  }\n}\nexport function defineSchema(schema, options) {\n  return new SchemaDefinition(schema, options);\n}\nconst _systemSchema = defineSchema({\n  _scheduled_functions: defineTable({\n    name: v.string(),\n    args: v.array(v.any()),\n    scheduledTime: v.float64(),\n    completedTime: v.optional(v.float64()),\n    state: v.union(\n      v.object({ kind: v.literal(\"pending\") }),\n      v.object({ kind: v.literal(\"inProgress\") }),\n      v.object({ kind: v.literal(\"success\") }),\n      v.object({ kind: v.literal(\"failed\"), error: v.string() }),\n      v.object({ kind: v.literal(\"canceled\") })\n    )\n  }),\n  _storage: defineTable({\n    sha256: v.string(),\n    size: v.float64(),\n    contentType: v.optional(v.string())\n  })\n});\n//# sourceMappingURL=schema.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nexport class FilterExpression {\n  /**\n   * @internal\n   */\n  constructor() {\n    // Property for nominal type support.\n    __publicField(this, \"_isExpression\");\n    // Property to distinguish expressions by the type they resolve to.\n    __publicField(this, \"_value\");\n  }\n}\n//# sourceMappingURL=vector_search.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nexport class Expression {\n  /**\n   * @internal\n   */\n  constructor() {\n    // Property for nominal type support.\n    __publicField(this, \"_isExpression\");\n    // Property to distinguish expressions by the type they resolve to.\n    __publicField(this, \"_value\");\n  }\n}\n//# sourceMappingURL=filter_builder.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nexport class SearchFilter {\n  /**\n   * @internal\n   */\n  constructor() {\n    // Property for nominal type support.\n    __publicField(this, \"_isSearchFilter\");\n  }\n}\n//# sourceMappingURL=search_filter_builder.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nexport class IndexRange {\n  /**\n   * @internal\n   */\n  constructor() {\n    // Property for nominal type support.\n    __publicField(this, \"_isIndexRange\");\n  }\n}\n//# sourceMappingURL=index_range_builder.js.map\n","\"use strict\";\nexport function validateArg(arg, idx, method, argName) {\n  if (arg === void 0) {\n    throw new TypeError(\n      `Must provide arg ${idx} \\`${argName}\\` to \\`${method}\\``\n    );\n  }\n}\nexport function validateArgIsInteger(arg, idx, method, argName) {\n  if (!Number.isInteger(arg)) {\n    throw new TypeError(\n      `Arg ${idx} \\`${argName}\\` to \\`${method}\\` must be an integer`\n    );\n  }\n}\nexport function validateArgIsNonNegativeInteger(arg, idx, method, argName) {\n  if (!Number.isInteger(arg) || arg < 0) {\n    throw new TypeError(\n      `Arg ${idx} \\`${argName}\\` to \\`${method}\\` must be a non-negative integer`\n    );\n  }\n}\n//# sourceMappingURL=validate.js.map\n","/* eslint-disable */\n/**\n * Generated `api` utility.\n *\n * THIS CODE IS AUTOMATICALLY GENERATED.\n *\n * To regenerate, run `npx convex dev`.\n * @module\n */\n\nimport { anyApi, componentsGeneric } from \"convex/server\";\n\n/**\n * A utility for referencing Convex functions in your app's API.\n *\n * Usage:\n * ```js\n * const myFunctionReference = api.myModule.myFunction;\n * ```\n */\nexport const api = anyApi;\nexport const internal = anyApi;\nexport const components = componentsGeneric();\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22]}